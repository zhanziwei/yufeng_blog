---
layout: post
title: TCP和UDP
date: 2021-04-19
Author: yufeng 
tags: [计网]
comments: true
toc: true
---

## TCP和UDP

TCP和UDP是传输层的两个协议，为特定应用程序提供数据传输服务。

#### TCP和UDP的区别

UDP：无连接、尽最大可能交付、没有拥塞控制、面向报文、支持一对一、一对多、多对多和多对一的交互通信。

TCP：面向连接，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，一对一通信。

##### TCP的头部结构

![这里写图片描述](https://img-blog.csdn.net/20180703144556482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTI1MjAy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. 源端口和目的端口

   各占2个字节，分别写入源端口号和目的端口号

2. 序号

   占4字节。TCP面向字节流。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。
   
3. 确认号

   占4字节，是期望收到对方下一个报文段的第一个数据字节的序号

4. 数据偏移

   占4字节，TCP报文段的首部长度

5. 保留

   占6位，保留为今后使用，目前置为0

6. 紧急URG（Urgent）

   当URG=1时，表示紧急指针字段有效，发送方TCP把紧急数据插入到本报文段数据的最前面

7. 确认ACK（Acknowlegment）

   当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.

8. 推送PSH（Push）

   发送方TCP把PSH置为1，并立即创建一个报文段发送。接收方TCP收到PSH为1的报文段，尽快地交付接收应用进程

9. 复位RST（Reset）

   当RST为1时，表明TCP连接中出现严重差错，必须释放连接后重新建立连接

10. 同步SYN（Synchronization）

    在连接时用来同步序号。SYN置为1表示这是一个连接请求或连接接受报文

11. 终止FIN（finis）

    当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

12. 窗口

    占2字节。窗口指的是发送本报文段的一方的接收窗口。告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。

13. 检验和

    占2字节。检验和字段检验的范围包括首部和数据这两部分。

14. 紧急指针

    占2字节。指出本报文段中的紧急数据的字节数

15. 选项

    长度可变，最长达40字节。当没有选项时，首部为20字节长。

#### TCP的三次握手和4次分手

![img](https://pic4.zhimg.com/80/v2-deea5fd11df64b45c7f325a90cef52bf_720w.jpg)

第一次握手：发送位码SYN=1，随机产生seq序列号x，主机B由SYN=1知道A要求建立联机。

第二次握手：主机B收到请求后要确认联机信息，向A发送ack Number=x+1, SYN=1,ACK=1，并也初始化seq=y。

第三次握手：主机A检查ack Number是否正确，以及校验位码ACK是否为1，如果正确，主机A会再发送seq number，ack number=y+1和ACK=1，主机B收到后确认seq值与ACK=1则连接建立成功。

![img](https://pic3.zhimg.com/80/v2-db5c6c352000712920657d39059416f6_720w.jpg)

第一次分手：客户端发送连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，序列号为seq=u，u是前面已经传过来的数据的最后一个字节的序号加1，此时客户端进入FIN-WAIT-1的状态，表示A没有数据要发送给B

第二次分手：服务器收到连接释放报文，发出ACK=1，seq=u+1,并且带上自己的序列号，服务端进入close-wait状态。

第三次分手：客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2的状态，等待服务器发送连接释放的报文，由于服务器可能又发送了一些数据，设此时的seq=w。服务器同意客户端关闭的请求。

第四次分手：客户端收到服务器的ACK报文段后向服务器发送ACK=1，ack=w+1，seq=u+1，客户端进入Time_wait状态；服务器收到客户端的ACK就关闭连接；客户端等待2MSL后依然没有回复，就证明服务器端已正常关闭。

#### 为什么要三次握手

为了防止已失效的连接请求报文段突然又传送给了B，会导致错误。如由于某些网络结点长时间滞留，延误到连接释放以后才到达B。

#### 为什么四次分手

当服务器端收到FIN报文，socket并不会立即关闭，所以只先回复一个ACK报文，只有当所有报文发送完以后才发送FIN。

客户端收到FIN报文以后，并不会立即CLOSED，而是进入TIME_WAIT，等待2MSL才进入CLOSED，为了确保最后一个确认报文能够到达，为了让本连接持续时间内所产生的报文都从网络上消失，使得下一个新的连接不会出现旧的连接请求报文。

#### TCP如何保证可靠传输

TCP通过以下几个性质来保证可靠运输

* 序号：TCP连接中传送的数据流中的每一个字节都编上一个序号，序号字段的值则指得是本报文段所发送的数据的第一个字节的序号
* 确认：TCP首部的确认号是期望收到对方的下一个报文段数据的第一个字节的序号，当数据发送出去后，发送方缓冲区会继续存储那些已经发送但未收到确认的报文段，以便在需要的时候重传，TCP默认使用累计确认,即TCP只确认数据流中至第一个丢失字节为止的字节。
* 重传：有两种事件会造成TCP对报文段进行重传：超时和冗余ACK
  1. 超时：TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传事件到期但还没有收到确认，就要重传这一报文段
  2. 冗余ACK(冗余确认)：冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认；TCP规定当发送方收到对同一个报文段的3个冗余ACK时,就可以认为跟在这个被确认报文段之后的报文段已经丢失;
*  校验: TCP将保持它首部和数据的校验和。这是一个端到端的校验和,目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错,TCP将丢弃这个报文段并且不确认(导致对方超时重传);
* 重排: TCP承载于IP数据报来传输,而IP数据报的到达可能会失序,因此TCP报文段的到达也可能会失序。TCP将对收到的数据进行重新排序。IP数据报会发生重复,TCP的接收端会丢弃重复的数据。
* 流量控制: TCP还能提供流量控制。TCP连接的每一方都有一定大小的缓冲空间。
* 拥塞控制：当网络拥塞时，减少数据的发送

#### 以字节为单位的滑动窗口





