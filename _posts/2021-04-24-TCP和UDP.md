---
layout: post
title: TCP和UDP
date: 2021-04-19
Author: yufeng 
tags: [计网]
comments: true
toc: true
---

## TCP和UDP

TCP和UDP是传输层的两个协议，为特定应用程序提供数据传输服务。

#### TCP和UDP的区别

UDP：无连接、尽最大可能交付、没有拥塞控制、面向报文、支持一对一、一对多、多对多和多对一的交互通信。

TCP：面向连接，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，一对一通信。

##### TCP的头部结构

![这里写图片描述](https://img-blog.csdn.net/20180703144556482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTI1MjAy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. 源端口和目的端口

   各占2个字节，分别写入源端口号和目的端口号

2. 序号

   占4字节。TCP面向字节流。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。
   
3. 确认号

   占4字节，是期望收到对方下一个报文段的第一个数据字节的序号

4. 数据偏移

   占4字节，TCP报文段的首部长度

5. 保留

   占6位，保留为今后使用，目前置为0

6. 紧急URG（Urgent）

   当URG=1时，表示紧急指针字段有效，发送方TCP把紧急数据插入到本报文段数据的最前面

7. 确认ACK（Acknowlegment）

   当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.

8. 推送PSH（Push）

   发送方TCP把PSH置为1，并立即创建一个报文段发送。接收方TCP收到PSH为1的报文段，尽快地交付接收应用进程

9. 复位RST（Reset）

   当RST为1时，表明TCP连接中出现严重差错，必须释放连接后重新建立连接

10. 同步SYN（Synchronization）

    在连接时用来同步序号。SYN置为1表示这是一个连接请求或连接接受报文

11. 终止FIN（finis）

    当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

12. 窗口

    占2字节。窗口指的是发送本报文段的一方的接收窗口。告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。

13. 检验和

    占2字节。检验和字段检验的范围包括首部和数据这两部分。

14. 紧急指针

    占2字节。指出本报文段中的紧急数据的字节数

15. 选项

    长度可变，最长达40字节。当没有选项时，首部为20字节长。

#### TCP的三次握手和4次分手

![img](https://pic4.zhimg.com/80/v2-deea5fd11df64b45c7f325a90cef52bf_720w.jpg)

第一次握手：发送位码SYN=1，选择一个初始seq序列号x，SYN报文段不携带数据，但要消耗掉一个序号。主机B由SYN=1知道A要求建立联机。

第二次握手：主机B收到请求后要确认联机信息，向A发送ack=x+1, SYN=1,ACK=1，并也初始化seq=y。也不能携带数据，但要消耗掉一个序号。

第三次握手：主机A检查ack Number是否正确，以及校验位码ACK是否为1，如果正确，主机A会再发送seq number，ack number=y+1和ACK=1，主机B收到后确认seq值与ACK=1则连接建立成功。

![img](https://pic3.zhimg.com/80/v2-db5c6c352000712920657d39059416f6_720w.jpg)

第一次分手：客户端发送连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，序列号为seq=u，u是前面已经传过来的数据的最后一个字节的序号加1，此时客户端进入FIN-WAIT-1的状态，表示A没有数据要发送给B

第二次分手：服务器收到连接释放报文，发出ACK=1，seq=u+1,并且带上自己的序列号，服务端进入close-wait状态。

第三次分手：客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2的状态，等待服务器发送连接释放的报文，由于服务器可能又发送了一些数据，设此时的seq=w。服务器同意客户端关闭的请求。

第四次分手：客户端收到服务器的ACK报文段后向服务器发送ACK=1，ack=w+1，seq=u+1，客户端进入Time_wait状态；服务器收到客户端的ACK就关闭连接；客户端等待2MSL后依然没有回复，就证明服务器端已正常关闭。

#### 为什么要三次握手

为了防止已失效的连接请求报文段突然又传送给了B，会导致错误。如由于某些网络结点长时间滞留，延误到连接释放以后才到达B。如果不采取三次握手，则B会误以为A又发出一次新的连接请求，向A发出确认报文段，同意建立连接，而A并不理睬B的确认，B一直等待。

#### 为什么四次分手

当服务器端收到FIN报文，socket并不会立即关闭，所以只先回复一个ACK报文，只有当所有报文发送完以后才发送FIN。

客户端收到FIN报文以后，并不会立即CLOSED，而是进入TIME_WAIT，等待2MSL才进入CLOSED，为了确保最后一个确认报文能够到达，为了让本连接持续时间内所产生的报文都从网络上消失，使得下一个新的连接不会出现旧的连接请求报文。

#### TIME_WAIT状态

1）为了保证客户端发送的最后一个ACK报文段能够达到服务器。这个ACK报文段可能丢失，因而使处在LAST_ACK状态的服务器收不到确认，这样的话, 服务器会超时重传FIN+ACK报文段,客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段,接着客户端重传一次确认,重启计时器。最后,客户端和服务器都正常进入到CLOSED状态。

如果客户端在TIME_WAIT状态不等待一段时间,而是在发送完ACK报文后立即释放连接,那么就无法收到服务器重传的FIN+ACK报文段,因而也不会再发送一次确认报文。这样,服务器就无法按照正常步骤进入CLOSED状态。

2）防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个ACK确认报文段后,再经过时间2MSL,就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

  注意:服务器结束TCP连接的时间要比客户端早一些,因为客户机(最先提出close请求的一端)最后要等待2MSL后才可以进入CLOSED状态。

#### TCP如何保证可靠传输

TCP通过以下几个性质来保证可靠运输

* 序号：TCP连接中传送的数据流中的每一个字节都编上一个序号，序号字段的值则指得是本报文段所发送的数据的第一个字节的序号
* 确认：TCP首部的确认号是期望收到对方的下一个报文段数据的第一个字节的序号，当数据发送出去后，发送方缓冲区会继续存储那些已经发送但未收到确认的报文段，以便在需要的时候重传，TCP默认使用累计确认,即TCP只确认数据流中至第一个丢失字节为止的字节。
* 重传：有两种事件会造成TCP对报文段进行重传：超时和冗余ACK
  1. 超时：TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传事件到期但还没有收到确认，就要重传这一报文段
  2. 冗余ACK(冗余确认)：冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认；TCP规定当发送方收到对同一个报文段的3个冗余ACK时,就可以认为跟在这个被确认报文段之后的报文段已经丢失;
*  校验: TCP将保持它首部和数据的校验和。这是一个端到端的校验和,目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错,TCP将丢弃这个报文段并且不确认(导致对方超时重传);
* 重排: TCP承载于IP数据报来传输,而IP数据报的到达可能会失序,因此TCP报文段的到达也可能会失序。TCP将对收到的数据进行重新排序。IP数据报会发生重复,TCP的接收端会丢弃重复的数据。
* 流量控制: TCP还能提供流量控制。TCP连接的每一方都有一定大小的缓冲空间。
* 拥塞控制：当网络拥塞时，减少数据的发送

#### 以字节为单位的滑动窗口

TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个`发送窗口`和一个`接收窗口`。各自的`接收窗口`大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的`发送窗口`则要求取决于对端通告的`接收窗口`，要求相同。

#### 窗口的概念

发送方的发送缓存内的数据都可以被分为4类:
1. 已发送，已收到ACK
2. 已发送，未收到ACK
3. 未发送，但允许发送
4. 未发送，但不允许发送

其中类型2和3都属于发送窗口。

接收方的缓存数据分为3类：
1. 已接收
2. 未接收但准备接收
3. 未接收而且不准备接收

其中类型2属于接收窗口。

#### 滑动机制

1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。

2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。

3. 遵循快速重传、累计确认、选择确认等规则。

4. 发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。

发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。通过调整发送方窗口和接收方窗口大小实现流量控制。且TCP通常对不按序到达的数据先临时存放在接收窗口内，等到字节流中所缺少的字节收到后，再按序交付上层的应用程序。

窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，获得更高的传输效率

#### 滑动窗口协议和停止等待协议的区别

滑动窗口中，允许发送方发送多个分组而不需要等待确认。滑动窗口协议是TCP用来流量控制的方法，加速数据的传输。当发送窗口和接收窗口的大小都等于1时，为停止等待协议。每发送完一个分组就停止发送，等待对方的确认，收到确认后再发送下一个分组。

#### TCP的流量控制

流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收，利用滑动窗口机制来实现对发送方的流量控制。

 接收窗口rwnd是接收端根据其目前的接收缓存大小所许诺的最新的窗口值,是来自接收端的流量控制。接收端将此窗口值放在 TCP 报文的首部中的窗口字段,传送给发送端，来限制发送方向网络注入报文的速率。

#### 拥塞控制

拥塞控制是防止过多的数据注入到网络中，使网络中的路由器或链路不至于过载。

拥塞窗口 cwnd (congestion window): 是发送端根据自己估计的网络拥塞程度而设置的窗口值,是来自发送端的流量控制。

把拥塞控制和流量控制一起考虑，发送窗口的上限值=Min(rwnd, cwnd)；

当网络发生拥塞时，路由器就要丢弃分组。因此只要发送方没有按时收到应当到达的确认报文，可猜测网络可能出现了拥塞。

##### 慢开始算法

在刚刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。使用慢开始算法，每经过一个传输轮次（往返时间RTT），拥塞窗口cwnd就加倍。这样一致把拥塞窗口cwnd增大到一个规定的慢开始阈值ssthresh，然后改用拥塞避免算法。

#### 拥塞避免算法

发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小,而不是加倍(不同于慢开始算法),使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时,则令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)，然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。目的是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压得分组处理完毕。

根据cwnd的大小执行不同的算法,可归纳如下:

​    当cwnd<ssthresh时,使用慢开始算法。

​    当cwnd>ssthresh时,停止使用慢开始算法而改用拥塞避免算法。

​    当cwnd=ssthresh时,既可使用慢开始算法,也可使用拥塞避免算法(通常做法)。

 在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法。“乘法减小”是指不论在慢开始阶段还是拥塞避免阶段,只要出现一次超时(即很可能出现了网络拥塞),就把慢开始门限值ssthresh设置为当前的拥塞窗口值的一半。当网络频繁出现拥塞时,ssthresh值就下降得很快,以大大减少注入到网络中的分组数。而“加法增大”是指执行拥塞避免算法后,在收到对所有报文段的确认后(即经过一个RTT),就把拥塞窗口cwnd增加一个MSS大小,使拥塞窗口缓慢增大,以防止网络过早出现拥塞。

#### 快重传与快恢复

1.快重传

  快重传算法要求接收方每收到一个失序得报文段后就立即发出重复确认。为得是让发送方及早知道有报文段没有到达对方。当发送方连续收到三个重复的ACK报文时,直接重传对方尚未收到的报文段,而不必等待那个报文段设置的重传计时器超时。提高吞吐量。

2.快恢复

  快恢复算法原理:当发送端收到连续三个冗余ACK(即重复确认)时,就执行“乘法减小”算法,把慢开始门限ssthresh减半。与慢开始(慢开始算法将拥塞窗口cwnd设置为1)不同之处是它把cwnd的值设置为慢开始门限ssthresh减半后的数值,然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大。

  由于跳过了cwnd从1起始的慢开始过程(因为既然现在能够收到三个重复ACK确认, 就说明拥塞程序并不是很大),所以被称为快恢复。

因为收到了连续重复确认，因此发送方认为网络很可能没有发生拥塞，因此采用快恢复算法。